#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <gio/gio.h>
#include <xmmsclient/xmmsclient.h>

// These files are generated by `gdbus-codegen`
// Run `cmake . && make` to generate them.
#include "mpris-object.h"
#include "mpris-player.h"

typedef struct App {
    xmmsc_connection_t* con;
    GDBusConnection* bus;
    MprisMediaPlayer2* main_object;
    MprisMediaPlayer2Player* player;
} App;

static App app;

/** Given any XMMS2 signal function, get an int from XMMS. */
int32_t get_xmms2_int(
    xmmsc_connection_t* con,
    xmmsc_result_t* (*func)(xmmsc_connection_t*),
    int32_t def
) {
    xmmsc_result_t* result = (*func)(con);
    xmmsc_result_wait(result);
    xmmsv_t* value = xmmsc_result_get_value(result);
    int32_t number;

    if (!xmmsv_get_int(value, &number)) {
        number = def;
    }

    xmmsc_result_unref(result);

    return number;
}

/** Get a string from a media item dictionary, or use a default. */
const char* get_dict_string(xmmsv_t* dict, const char* key, const char* def) {
    xmmsv_t *item;
    const char* value;

    if (!xmmsv_dict_get(dict, key, &item) || !xmmsv_get_string(item, &value)) {
        return def;
    }

    return value;
}

int32_t get_dict_int(xmmsv_t* dict, const char* key, int32_t def) {
    xmmsv_t *item;
    int32_t value;

    if (!xmmsv_dict_get(dict, key, &item) || !xmmsv_get_int(item, &value)) {
        return def;
    }

    return value;
}

/**
 * Get info about the currently playing track.
 *
 * The dictionary will be set up with the following keys.
 *
 * added              - ???
 * album              - The album as a string.
 * artist             - The artiest as a string.
 * bitrate            - The bitrate.
 * chain              - ???
 * channels           - The channels for the track.
 * date               - The date of the track.
 * duration           - The duration of the track in milliseconds as an int.
 * genre              - The genre of the track as a string.
 * id                 - The media entry ID.
 * isvbr              - If the track uses variable rate.
 * laststarted        - ???
 * lmod               - Last modified?
 * mime               - The mimetype for the track.
 * picture_front      - A picture for the track?
 * picture_front_mime - The mimetype of the picture?
 * sample_format      - The sample format?
 * samplerate         - The sample rate.
 * size               - The size of the track.
 * status             - ???
 * timesplayed        - The number of times played.
 * title              - The title of the track as a string.
 * tracknr            - The track number.
 * url                - A URL for the track.
 */
xmmsc_result_t* get_media_info(
    xmmsc_connection_t* con,
    int32_t id,
    xmmsv_t** dict
) {
    xmmsc_result_t* result = xmmsc_medialib_get_info(con, id);
    xmmsc_result_wait(result);
    xmmsv_t* value = xmmsc_result_get_value(result);

    *dict = xmmsv_propdict_to_dict(value, NULL);

    return result;
}


GVariant* new_metadata_dict_string(const char* key, const char* value) {
    return g_variant_new_dict_entry(
        g_variant_new_string(key),
        g_variant_new_variant(g_variant_new_string(value))
    );
}

GVariant* new_metadata_dict_int64(const char* key, int64_t value) {
    return g_variant_new_dict_entry(
        g_variant_new_string(key),
        g_variant_new_variant(g_variant_new_int64(value))
    );
}

/** This function can be used to print a whole dictionary for debugging. */
void print_dict(xmmsv_t* dict) {
    xmmsv_dict_iter_t* it;

    if (!xmmsv_get_dict_iter(dict, &it)) {
        fprintf(stderr, "Could not get an iterator\n");
        return;
    }

    while(xmmsv_dict_iter_valid(it)) {
        const char* key;
        xmmsv_t * value;
        xmmsv_dict_iter_pair(it, &key, &value);

        printf("%s \n", key);

        xmmsv_dict_iter_next(it);
    }
}

typedef struct XmmsTrackInfo {
    int32_t id;
    int32_t playtime;
    const char* status;
    const char* artist;
    const char* title;
    const char* album;
    const char* url;
    int32_t duration;
    xmmsv_t* _xmms_dict;
    xmmsc_result_t* _xmms_media_result;
} XmmsTrackInfo;

void get_xmms_track_info(XmmsTrackInfo* info) {
    int32_t status_id = get_xmms2_int(app.con, xmmsc_playback_status, 0);

    // These strings are the three values mpris requires.
    switch(status_id) {
    case XMMS_PLAYBACK_STATUS_PLAY:
        info->status = "Playing";
    break;
    case XMMS_PLAYBACK_STATUS_PAUSE:
        info->status = "Paused";
    break;
    default:
        info->status = "Stopped";
    break;
    }

    info->playtime = get_xmms2_int(app.con, xmmsc_playback_playtime, 0);
    info->id = get_xmms2_int(app.con, xmmsc_playback_current_id, 0);

    info->_xmms_dict = NULL;
    info->_xmms_media_result = get_media_info(app.con, info->id, &(info->_xmms_dict));

    info->duration = get_dict_int(info->_xmms_dict, "duration", 0);
    info->artist = get_dict_string(info->_xmms_dict, "artist", "");
    info->title = get_dict_string(info->_xmms_dict, "title", "");
    info->album = get_dict_string(info->_xmms_dict, "album", "");
    info->url = get_dict_string(info->_xmms_dict, "url", "");
}

void get_xmms_track_info_unref(XmmsTrackInfo* info) {
    xmmsv_unref(info->_xmms_dict);
    xmmsc_result_unref(info->_xmms_media_result);
}

void diplay_track_info(XmmsTrackInfo* info) {
    GVariant* entries[7];
    int length = 0;

    entries[length++] = new_metadata_dict_string("mpris:trackid", "/org/mpris/MediaPlayer2/CurrentTrack");

    if (info->title && strlen(info->title)) {
        entries[length++] = new_metadata_dict_string("xesam:title", info->title);
    } else {
        entries[length++] = new_metadata_dict_string("xesam:title", "Unknown Track");
    }

    if (info->artist && strlen(info->artist)) {
        entries[length++] = new_metadata_dict_string("xesam:artist", info->artist);
    }

    if (info->album && strlen(info->album)) {
        entries[length++] = new_metadata_dict_string("xesam:album", info->album);
    }

    if (info->url && strlen(info->url)) {
        entries[length++] = new_metadata_dict_string("xesam:url", info->url);
    }

    entries[length++] = new_metadata_dict_int64("mpris:length", info->duration);

    GVariant* dict = g_variant_new_array(G_VARIANT_TYPE("{sv}"), entries, length);
    mpris_media_player2_player_set_metadata(app.player, dict);

    mpris_media_player2_player_set_playback_status(app.player, info->status);
}

GDBusConnection* get_dbus_connection() {
    GError* error = NULL;
    GDBusConnection* bus = g_bus_get_sync(G_BUS_TYPE_SESSION, NULL, &error);

    if (!bus) {
        fprintf(stderr, "%s\n", error->message);
        g_error_free(error);
    } else {
        // Register this program as the mpris handler.
        g_bus_own_name_on_connection(
            bus, "org.mpris.MediaPlayer2.xmms2",
            0, NULL, NULL, NULL, NULL
        );
    }

    return bus;
}

MprisMediaPlayer2* init_main_dbus_object(GDBusConnection* bus) {
    // Set up the main media player object.
    MprisMediaPlayer2* main_object = mpris_media_player2_skeleton_new();

    // See the properties in mpris2.xml.
    mpris_media_player2_set_can_quit(main_object, false);
    mpris_media_player2_set_can_raise(main_object, false);
    mpris_media_player2_set_has_track_list(main_object, false);
    mpris_media_player2_set_identity(main_object, "XMMS2");
    mpris_media_player2_set_desktop_entry(main_object, "xmms2");

    // TODO(later) Implement the quit method.
    // TODO(later) Implement the raise method with lxmusic?

    GError* error = NULL;

    if (!g_dbus_interface_skeleton_export(
        (GDBusInterfaceSkeleton*) main_object,
        bus,
        "/org/mpris/MediaPlayer2",
        &error
    )) {
        fprintf(stderr, "%s\n", error->message);
        g_error_free(error);
        g_object_unref(main_object);

        main_object = NULL;
    }

    return main_object;
}

MprisMediaPlayer2Player* init_player_dbus_object(GDBusConnection* bus) {
    MprisMediaPlayer2Player* player = mpris_media_player2_player_skeleton_new();

    mpris_media_player2_player_set_playback_status(player, "Stopped");
    mpris_media_player2_player_set_rate(player, 0);
    mpris_media_player2_player_set_volume(player, 0);
    // The position uses the time in microseconds.
    mpris_media_player2_player_set_position(player, 0);
    mpris_media_player2_player_set_minimum_rate(player, 0);
    mpris_media_player2_player_set_maximum_rate(player, 0);
    mpris_media_player2_player_set_can_go_next(player, false);
    mpris_media_player2_player_set_can_go_previous(player, false);
    mpris_media_player2_player_set_can_play(player, false);
    mpris_media_player2_player_set_can_pause(player, false);
    mpris_media_player2_player_set_can_seek(player, false);
    mpris_media_player2_player_set_can_control(player, false);

    // TODO(later) Implement the next method.
    // TODO(later) Implement the previous method.
    // TODO(later) Implement the pause method.
    // TODO(later) Implement the playpause method.
    // TODO(later) Implement the stop method.
    // TODO(later) Implement the play method.
    // TODO(later) Implement the seek method.
    // TODO(later) Implement the setposition method.
    // TODO(later) Implement the openuri method.

    GError* error = NULL;

    if (!g_dbus_interface_skeleton_export(
        (GDBusInterfaceSkeleton*) player,
        bus,
        "/org/mpris/MediaPlayer2",
        &error
    )) {
        fprintf(stderr, "%s\n", error->message);
        g_error_free(error);
        g_object_unref(player);

        player = NULL;
    }

    return player;
}

int setup_app() {
    xmmsc_connection_t* con = con = xmmsc_init("xmms2-mpris");

    if (!con) {
        return 1;
    }

    if (!xmmsc_connect(con, getenv("XMMS_PATH"))) {
        fprintf(stderr, "Connection failed: %s\n", xmmsc_get_last_error(con));

        return 1;
    }

    GDBusConnection* bus = get_dbus_connection();

    if (!bus) {
        return 1;
    }

    // Set up the main media player object.
    MprisMediaPlayer2* main_object = init_main_dbus_object(bus);

    if (!main_object) {
        return 1;
    }

    MprisMediaPlayer2Player* player = init_player_dbus_object(bus);

    if (!player) {
        return 1;
    }

    app.con = con;
    app.bus = bus;
    app.main_object = main_object;
    app.player = player;

    return 0;
}

static gboolean timer_callback(G_GNUC_UNUSED gpointer data) {
    XmmsTrackInfo xmms_info;

    get_xmms_track_info(&xmms_info);
    diplay_track_info(&xmms_info);
    get_xmms_track_info_unref(&xmms_info);

    return true;
}

int main(int argc, char** argv) { // NOLINT
    if (setup_app()) {
        return 1;
    }

    GMainLoop *loop = g_main_loop_new(NULL, false);

    g_timeout_add(1000, timer_callback, NULL);

    g_main_loop_run(loop);

    // Clean up.
    g_object_unref(app.main_object);
    g_object_unref(app.player);

    return 0;
}
